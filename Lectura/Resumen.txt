"Practical Byzantine Fault Tolerance" por Castro y Liskov, describe un algoritmo de replicación capaz de funcionar a pesar de fallas bizantinas. Un algoritmo de replicación permite que, para asegurar la correctitud de una función, la misma sea ejecutada múltiples veces por módulos independientes que tengan distintas aplicaciones de la misma función, y se ejecuten en sistemas operativos distintos.
La idea es que si vemos que parte importante de los módulos coiciden en el resultado de la operación, entonces retornemos el resultado con la seguridad de que es correcto.
En palabras simples, el algoritmo funciona de la siguiente manera: en primer lugar, necesitamos el número máximo permitido de nodos corruptos "f", a partir de él, podemos definir la cantidad de nodos necesarios para asegurar correctitud: |R| = 3f +1. Una vez definidos ambos parámetros, definimos la view "v" la cual podemos calcular de la siguiente forma: p = v mod R, donde "p" es el ID del nodo primario (con quien se comunican los clientes directamente) de la view "v". Todos los nodos tienen el mismo estado inicial donde se define el nodo primario y, por lo tanto, la view.
La idea de la existencia de nodos primarios y views es que, si el nodo primario presenta evidencias de corrupción, los nodos pueden organizarse y actualizar la view para que un nodo sano asuma la comunicación con los clientes de ahí en adelante.
Una vez definido el nodo primario, los clientes pueden hacer requests a este pidiendo la ejecución de una operación en especiífico. Luego, el nodo primario envía al resto de los nodos una instrucción para que cada uno ejecute su versión de la función, y conteste el resultado directamente al cliente. Cuando el cliente recibe f+1 resultados iguales, termina la operación y acepta el resultado como final. Es importante que sean f+1, ya que así se asegura de que al menos una respuesta proviene de un nodo sano (ya que hay máximo f nodos corruptos), y el cliente tiene la seguridad de estar recibiendo una respuesta válida.

Funcionamiento detallado del algoritmo: Para solicitar la ejecucuión de una operación, el cliente envía un request R(o, t, c) con o = operación, t = timestamp (para que el nodo primario pueda ordenar las solicitudes), c = ID de cliente. Cada respuesta de los nodos al cliente incluye la view actual, por lo que el cliente siempre tiene presente el nodo primario y tiene la siguiente estructura: R(v, t, c, i, r) v = view, t = timestamp, c = ID cliente, i = ID nodo, r = respuesta.
Si el cliente no recibe respuestas, envía la request a todos los nodos para insistir en que contesten, si el nodo no había contestado, ejecuta y contesta, si había contestado pero el mensaje falló a lo largo de la red antes de llegar al cliente, cada nodo tiene un registro de todos sus mensajes enviados, y le vuelve a enviar al cliente el mensaje con el c y t correspondientes a la solicitud.
Hay tres etapas una vez que el nodo primario recibe un mensaje de un cliente: pre-prepare, prepare y commit. En pre-prepare, el nodo primario asigna un número n a la request, y envía un mensaje pre-prepare al resto de los nodos con la siguiente estructura: ((Pre-prepare, v, n, d), m) donde v = view, n = número designado a la request, d = hash de m, m = mensaje enviado por cliente.
Los nodos no primarios aceptan un mensaje pre-prepare si y sólo si d es el hash de m, v coincide con su view, no ha aceptado otro mensaje pre-prepare para la misma view y el mismo n con un d distinto, h <= n <= H donde h y H son límites inferiores y superiores establecidos para que un nodo primario no elija un n muy grande, poniendo en riesgo su capacidad para representar números > n.
Si un nodo acepta un mensaje pre-prepare, entra en la etapa prepare y envía un mensaje prepare (Prepare, v, n, d, i) a todos los demás nodos réplica. Los nodos aceptan los mensajes prepare si v coincide con su view, y h <= n <= H.
Pre-prepare y Prepare aseguran que los nodos sanos coincidan en el orden de prioridad de las requests. Una vez en estadoprepare, los nodos envían un mensaje (COMMIT, v, n, d, i) las cuales aceptan el mensaje si v = view y h <= n <= H. Ahora, definimos las siguientes condiciones: commited(m, v, n) es verdadero si f+1 nodos sanos están en estado prepared. commited_local(m, v, n, i) es verdadero si el nodo i está en estado prepared y ha recibido y aceptado (2f + 1) commits.
Una vez en estado commit, el nodo realiza la operación y envía su respuesta al cliente.
Cuando el cliente recibe f + 1 respuestas iguales, asume el valor de esas rspuestas como el corrrecto.
Este algoritmo asegura la correctitud de las respuestas con hasta f nodos bizantinos y es capaz de ejecutarse en tiempos eficientes para aplicaciones en la vida real.